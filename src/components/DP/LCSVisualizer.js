// LCSVisualizer.js
// This component visualizes the Longest Common Subsequence (LCS) dynamic programming solution.
// It builds the DP table step-by-step while highlighting the current cell being computed.
// Once the DP table is fully built, a "Computation Complete!" message is displayed.
// All styles are managed via an external CSS file (LCSVisualizer.css).

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import '../CSS/LCSVisualizer.css';

/**
 * buildLCSSteps - Builds the DP table for LCS step by step.
 *
 * @param {string} str1 - First string.
 * @param {string} str2 - Second string.
 * @returns {Array} steps - Array of snapshot objects containing:
 *    - i: current row index,
 *    - j: current column index,
 *    - dp: a deep copy of the current DP table,
 *    - description: a string describing the current step.
 */
function buildLCSSteps(str1, str2) {
  const m = str1.length;
  const n = str2.length;
  const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));
  const steps = [];
  
  // Record initial DP table state.
  steps.push({
    i: 0,
    j: 0,
    dp: dp.map(row => [...row]),
    description: "Initialize DP table with zeros",
  });
  
  // Build the DP table row by row.
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (str1[i - 1] === str2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
      // Record snapshot after computing dp[i][j].
      steps.push({
        i,
        j,
        dp: dp.map(row => [...row]),
        description: `Computed dp[${i}][${j}]`,
      });
    }
  }
  return steps;
}

/**
 * BoardDiagram Component
 * Renders the DP table as an SVG grid.
 * The cell corresponding to the current step (i, j) is highlighted in orange,
 * while other cells are displayed in green.
 *
 * @param {Object} props - Contains:
 *   - dp: 2D array representing the DP table.
 *   - currentCell: Object with properties { i, j } indicating the current cell.
 */
function BoardDiagram({ dp, currentCell }) {
  const rows = dp.length;
  const cols = dp[0].length;
  const cellSize = 40;
  return (
    <svg width={cols * cellSize + 20} height={rows * cellSize + 20} className="lcs-svg">
      {dp.map((row, i) =>
        row.map((val, j) => {
          const isCurrent = currentCell && currentCell.i === i && currentCell.j === j;
          return (
            <motion.rect
              key={`cell-${i}-${j}`}
              x={j * cellSize + 10}
              y={i * cellSize + 10}
              width={cellSize}
              height={cellSize}
              fill={isCurrent ? "#FF8C00" : "#90EE90"}
              stroke="#fff"
              strokeWidth="2"
              whileHover={{ scale: 1.05 }}
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3, delay: (i * cols + j) * 0.02 }}
            />
          );
        })
      )}
      {dp.map((row, i) =>
        row.map((val, j) => (
          <text
            key={`label-${i}-${j}`}
            x={j * cellSize + cellSize / 2 + 10}
            y={i * cellSize + cellSize / 1.5 + 10}
            textAnchor="middle"
            fontSize="14"
            fill="#fff"
          >
            {val}
          </text>
        ))
      )}
    </svg>
  );
}

/**
 * AlgorithmVisualizer Component
 * Animates through the DP table snapshots generated by buildLCSSteps.
 * Once the final step is reached, a "Computation Complete!" message is shown.
 *
 * @param {Object} props - Contains:
 *   - steps: Array of DP table snapshots.
 *   - speed: Visualization speed in milliseconds.
 */
function AlgorithmVisualizer({ steps, speed }) {
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  
  // Reset the step index whenever steps update.
  useEffect(() => {
    setCurrentStepIndex(0);
  }, [steps]);
  
  // Animate through the steps automatically.
  useEffect(() => {
    if (steps.length === 0) return;
    const interval = setInterval(() => {
      setCurrentStepIndex(prev => {
        if (prev < steps.length - 1) return prev + 1;
        clearInterval(interval);
        return prev;
      });
    }, speed);
    return () => clearInterval(interval);
  }, [steps, speed]);
  
  const currentStep = steps[currentStepIndex] || { dp: [[]], i: null, j: null };

  return (
    <div className="lcs-visualizerContainer">
      <motion.h4
        className="lcs-stepHeader"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
      >
        Step {currentStepIndex} â€“ {currentStep.description}
      </motion.h4>
      <BoardDiagram dp={currentStep.dp} currentCell={{ i: currentStep.i, j: currentStep.j }} />
      <AnimatePresence>
        {currentStepIndex === steps.length - 1 && (
          <motion.div
            className="lcs-completeMessage"
            initial={{ scale: 0, opacity: 0 }}
            animate={{ scale: 1.2, opacity: 1 }}
            exit={{ scale: 0, opacity: 0 }}
            transition={{ type: "spring", stiffness: 100 }}
          >
            Computation Complete!
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

/**
 * MyCompilerEditor Component
 * Dummy component for Practice Mode that embeds an online code editor.
 */
function MyCompilerEditor() {
  return (
    <div className="lcs-editorContainer">
      <motion.h3
        className="lcs-editorHeader"
        initial={{ opacity: 0, x: -50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 0.8 }}
      >
        MyCompiler Editor (Practice Mode)
      </motion.h3>
      <motion.p
        className="lcs-editorText"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 1 }}
      >
        <iframe
          src="https://www.onlinegdb.com/"
          title="MyCompiler Editor"
          className="lcs-editorFrame"
        />
      </motion.p>
    </div>
  );
}

/**
 * LCSVisualizer Component
 * Main component that renders the LCS Visualizer.
 * Users can input two strings; the component builds the DP table for the LCS problem
 * step-by-step and animates through each update. Computation starts automatically on mount.
 *
 * Mode toggle allows switching between theory and practice.
 */
export default function LCSVisualizer() {
  const [str1, setStr1] = useState("AGGTAB");
  const [str2, setStr2] = useState("GXTXAYB");
  const [steps, setSteps] = useState([]);
  const [speed, setSpeed] = useState(500);
  const [mode, setMode] = useState("theory");

  // Compute LCS steps automatically on mount and whenever strings change.
  useEffect(() => {
    const computedSteps = buildLCSSteps(str1, str2);
    setSteps(computedSteps);
  }, [str1, str2]);

  const runLCS = () => {
    const computedSteps = buildLCSSteps(str1, str2);
    setSteps(computedSteps);
  };

  const theoryContent = (
    <>
      <motion.h3
        className="lcs-sectionHeader"
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        Algorithm Theory & Pseudocode
      </motion.h3>
      <motion.p
        className="lcs-paragraph"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 1 }}
      >
        The Longest Common Subsequence (LCS) problem is solved using dynamic programming.
        Given two strings, we build a DP table where dp[i][j] represents the length of the LCS
        of the first i characters of the first string and the first j characters of the second string.
        If the characters match, dp[i][j] = dp[i-1][j-1] + 1; otherwise, dp[i][j] = max(dp[i-1][j], dp[i][j-1]).
      </motion.p>
      <motion.pre
        className="lcs-codeBlock"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 1 }}
      >
{`function buildLCSSteps(str1, str2):
  m = str1.length, n = str2.length
  dp = Array(m+1) x Array(n+1) filled with 0
  steps = []
  for i = 1 to m:
    for j = 1 to n:
      if str1[i-1] == str2[j-1]:
        dp[i][j] = dp[i-1][j-1] + 1
      else:
        dp[i][j] = max(dp[i-1][j], dp[i][j-1])
      record snapshot in steps
  return steps`}
      </motion.pre>
      <motion.h3
        className="lcs-sectionHeader"
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.8 }}
      >
        Time Complexity
      </motion.h3>
      <motion.ul
        className="lcs-list"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 1 }}
      >
        <li>O(m*n) time and space, where m and n are the lengths of the two strings.</li>
      </motion.ul>
    </>
  );

  return (
    <div className="lcs-pageContainer">
      <motion.h2
        className="lcs-pageHeader"
        initial={{ opacity: 0, x: -50 }}
        animate={{ opacity: 1, x: 0 }}
        transition={{ duration: 1 }}
      >
        LCS Visualizer
      </motion.h2>
      <div className="lcs-inputContainer">
        <label className="lcs-inputLabel">String 1:</label>
        <br />
        <input
          type="text"
          value={str1}
          onChange={(e) => setStr1(e.target.value)}
          className="lcs-textInput"
        />
        <br />
        <label className="lcs-inputLabel">String 2:</label>
        <br />
        <input
          type="text"
          value={str2}
          onChange={(e) => setStr2(e.target.value)}
          className="lcs-textInput"
        />
        <br />
        <motion.button
          className="lcs-primaryButton"
          whileHover={{ scale: 1.05, rotate: 1 }}
          onClick={runLCS}
        >
          Calculate LCS Length
        </motion.button>
      </div>
      <div className="lcs-inputContainer">
        <label className="lcs-inputLabel">Visualization Speed: {speed}ms</label>
        <br />
        <input
          type="range"
          min="50"
          max="1000"
          step="50"
          value={speed}
          onChange={(e) => setSpeed(Number(e.target.value))}
          className="lcs-slider"
        />
        <select
          onChange={(e) => setSpeed(Number(e.target.value))}
          className="lcs-dropdown"
          defaultValue={500}
        >
          <option value={1000}>Slow</option>
          <option value={500}>Medium</option>
          <option value={50}>Fast</option>
        </select>
      </div>
      <div className="lcs-inputContainer">
        <motion.button
          className={`lcs-toggleButton ${mode === "theory" ? "lcs-activeToggle" : ""}`}
          whileHover={{ scale: 1.1 }}
          onClick={() => setMode("theory")}
          disabled={mode === "theory"}
        >
          Theory
        </motion.button>
        <motion.button
          className={`lcs-toggleButton ${mode === "practice" ? "lcs-activeToggle" : ""}`}
          whileHover={{ scale: 1.1 }}
          onClick={() => setMode("practice")}
          disabled={mode === "practice"}
        >
          Practice
        </motion.button>
      </div>
      <AnimatePresence>
        {steps.length > 0 && <AlgorithmVisualizer steps={steps} speed={speed} />}
      </AnimatePresence>
      {mode === "theory" ? (
        <div className="lcs-theoryContainer">
          {theoryContent}
        </div>
      ) : (
        <MyCompilerEditor />
      )}
      <style>{`
        /* Hide scrollbar in case any container overflows */
        ::-webkit-scrollbar {
          display: none;
        }
      `}</style>
    </div>
  );
}




